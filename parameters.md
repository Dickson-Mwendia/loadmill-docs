# Parameters

Working with [Loadmill](https://www.loadmill.com) makes it very easy to convert recorded browser/netwrok sessions (via HAR files) into test scenarios. But once a scenario has been created, it often needs to **parametrized** in order to denote the dynamic parts of your API.

This is best explained by example, so let's have a look at the following test scenario:

1. User adds a blog post: `curl https://www.myblog.com/posts --data "Hello World!"`

2. User likes his own post: `curl -X PUT https://www.myblog.com/posts/123/like`

The `123` part is the identifier of the blog post created by the user - it cannot be known in advance because it is generated by the server at runtime. This is a very common use case for **parameters** and is handeled by two simple steps:

1. [Extract](#parameter-extraction) the ID from the first response into a parameter: `postId`

2. Embed the parameter in the second request URL: `https://www.myblog.com/posts/${postId}/like`

You may embed parameters with the `${}` syntax in the request URL as well as the request body, request headers, [extractions](#parameter-extraction), [assertions](assertions.html) and more.

Note that any parametrized expression such as `Some ${param}` will remain as-is if no such parameter is defined or extracted before the expression is evaluated.

## Default Parameters

Another common use case for parametrization is when you want to **reuse test scenarios** on different environments or with small adjustments.

Let's extend our first example by requiring that the user provide credentials via **basic authentication**. This means our new URLs could look like this:

1. `https://testUser:testPassword@www.myblog.com/posts`

2. `https://testUser:testPassword@www.myblog.com/posts/${postId}/like`

If you would like to use different credentials for every test run, you may replace the username and password with parameters and set their values in the **parameter defaults** section in your test scenario whenever you reuse the test. So now the URLs will look like:

1. `https://${user}:${pass}@www.myblog.com/posts`

2. `https://${user}:${pass}@www.myblog.com/posts/${postId}/like`

Using parameter defaults is especially useful for automated testing and CI where you may be testing a different server every time you run a test. Please refer to the [Loadmill CLI and node module](https://www.npmjs.com/package/loadmill#parameters) for more information about how to inject parameters dynamically.

## Built-in Parameters

There are several **built-in** parameter constructs that you can use in your test scenario. They are:

- `__status` The status code of the last HTTP response.
- `__statusText` The status text of the last HTTP response.
- `__responseTime` The total response time (in milliseconds) of the last HTTP response.
- `__random_uuid` A random v4 UUID string.
- `__random_boolean` A random boolen value (either `true` or `false` with %50 probability). By suffixing the name with an integer between 0 and 100, you can set the probability of getting `true`, e.g. the parameter `__random_boolean_75` will resolve to `true` with %75 probability.
- `__random_number` A random integer between 0 and 2<sup>32</sup>. By suffixing the name with a positive number you can set a lower maximum, e.g. `__random_number_30` will resolve to a number between 0 and 30, inclusive. You can also set the minimum, e.g. `__random_number_10_30` will be between 10 and 30, inclusive.

You may specify a different length to each of the following random parameters by appending it to the parameter name with a preceding underscore, e.g. `__random_chars_5` may resolve to `gK2x9`.

- `__random_chars` A random string of 10 (alpha-numeric) characters. 
- `__random_digits` 10 random digits. 
- `__random_letters` 10 random letters.
- `__random_uppers` 10 random uppercase letters.
- `__random_lowers` 10 random lowercase letters.
- `__random_hex` 10 random (lowercase) hexadecimal characters.
- `__random_<ANY_CHARACTERS>` 10 random characters chosen from the given suffix, e.g. you may generate a random **uppercase** hexadecimal string using a parameter named `__random_0123456789ABCDEF`.

## Parameter Extraction

Parameters can be defined and populated with values dynamically after each request in your test scenario. There are several **extraction query  types** that may be used:

1. **JSONPath** - used for extarcting values from a JSON response. For example, the query `post.id` will extract the value `123` from this JSON response:
```json
    {
        "post": {
            "id": 123,
            "text": "Hello World!"
        }
    }
```
2. **JQuery (Cheerio)** - used for extracting values from XML/HTML responses. We use a subset of the JQuery selector syntax called [Cheerio](https://cheerio.js.org).

3. **JS RegExp** - used for extracting arbitrary values from any kind of textual response via regular expressions with capture groups. For example, we can extract the `id` field from the same JSON response we've seen above using a regular expression: `.*"id":\s*([0-9]*)`.

4. **Header** - used for extracting response header values via header names.

5. **Assignment** - used for assigning an explicit value to a parameter. Previously defined or built-in parameters may be embedded within the string, e.g. `${protocol}://${host}:${port}` or `give me a ${__random_uppers_1}!`.

Previously defined or built-in parameters may be embedded within **any kind of extraction query**. These parameters will be evaluated right before the query itself is evaluated.




